#!/usr/bin/perl

use strict;
use threads;
use Dancer;

set port => 80;
set logger => 'console';
set engines => { JSON => { canonical => 1 } };

my $sender = "/usr/local/sbin/pilight-send -p raw -c";
my $config_file = "/opt/433ctrl/devices.json";

get '/list' => sub {
  my ($config, $devices) = load_config();
  return to_json $config;
};

get '/state' => sub {
  my ($config, $devices) = load_config();
  if (exists $devices->{params->{device}}) {
    my $format = exists params->{format}? params->{format}: "";
    if ($format eq "string") {
      return uc($devices->{params->{device}}->{state});
    } elsif ($format eq "switch") {
      my $out = uc($devices->{params->{device}}->{state});
      if ($out ne "ON") {
	$out = "OFF";
      }
      return $out;
    } else { # json is default
      return to_json({"state" => uc($devices->{params->{device}}->{state})});
    }
  } else {
    send_error("unknown device", 404);
    return;
  }
};

get '/switch' => sub {
  my ($config, $devices) = load_config();
  if (exists $devices->{params->{device}}) {
    print "a";
    if (params->{to} eq "on" or params->{to} eq "off") {
      set_state($config, $devices, params->{device}, params->{to});
      return to_json({"success" => "true"});
    } else {
      send_error("wrong state", 400);
    }
  } else {
    send_error("unknown device", 404);
  }
};

init();
async {
    while (1) {
        sleep 60;
        init();
    }
};
start();

sub init {
  my ($config, $devices) = load_config();
  foreach my $dev (values %{$devices}) {
    state_check($config, $dev);
  }
}

sub load_config {
  open F, "<$config_file" or die "error opening $config_file: $!";
  my $data;
  $data .= $_ while (<F>);
  close F;
  my $config = from_json $data;
  my $devices = {};
  foreach my $dev (@{$config->{devices}}) {
    $devices->{$dev->{id}} = $dev;
  }
  return ($config, $devices);
}

sub save_config {
  my $config = shift;
  my $data = to_json $config;
  open F, ">$config_file" or die "error opening $config_file: $!";
  print F $data;
  close F;
}

sub set_state {
  my $config = shift;
  my $devices = shift;
  my $dev = shift;
  my $state = shift;
  my $code = $devices->{$dev}->{$state."_code"};

  my @pre_cmds;
  my @post_cmds;
  if (exists $devices->{$dev}->{$state."_pre_commands"}) {
    @pre_cmds = @{$devices->{$dev}->{$state."_pre_commands"}};
  }
  if (exists $devices->{$dev}->{$state."_post_commands"}) {
    @post_cmds = @{$devices->{$dev}->{$state."_post_commands"}};
  }

  # set state to pending
  $devices->{$dev}->{state} = "turning $state";
  save_config($config);

  async {
    # run pre commands
    foreach my $cmd (@pre_cmds) {
      system "$cmd";
    }
    # switch the socket
    system "$sender \"$code\"";
    # run post commands
    foreach my $cmd (@post_cmds) {
      system "$cmd";
    }
    $devices->{$dev}->{state} = $state;
    save_config($config);
  };
}

sub state_check {
  my $config = shift;
  my $device = shift;
  if (exists $device->{state_check}) {
    my $state = `$device->{state_check}`;
    chomp $state;
    if (($state eq "on" or $state eq "off") and $state ne $device->{state}) {
      $device->{state} = $state;
      save_config($config);
    }
  }
}
